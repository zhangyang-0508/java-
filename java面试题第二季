1，面试题：谈谈对volatitle关键字的理解
volatitle：是java虚拟机提供的轻量级的同步机制
  1, 保证可见性
  2，不保证原子性
  3，禁止指令重排
  多线程情况下，普通的变量是没有可见性的，加了volatile关键字可以保证可见性
如何解决原子性：加sync  ,使用juc下的AtomicInterger(底层是CAS)

2,面试题：JMM（java内存模型）你谈谈？
  硬盘<内存<cpu
   主内存：电脑内存，比如8g,16g
   自己的工作内存：比如每个线程从主内存中拷贝到各自线程的工作内存
   可见性：一个线程修改了主物理内存，其它线程也能看到
 JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规范或者规则，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式
   JMM关于同步的规定：
      1，线程解锁前，必须把共享变量的值刷新回主内存
      2，线程加锁前，必须读取主内存的最新值到自己的工作内存
      3，加锁解锁是同一把锁
   JMM要求：可见性，原子性，有序性   
    线程安全保证
   
      
  由于jvm运行程序的实体是线程，而每个线程创建时，JVM都会为其创建一个工作内存，（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而java
    内存模型中规定多有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将
     变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储
     着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成
     
     原子性指的是什么意思？不可分割，也即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整要么同时成功，要么同时失败
       number++在多线程下是非线程安全的
       
 计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分为三种
   源代码-》编译器优化的重排-》指令并行的重排-》内存系统的重排-》最终执行的指令
  单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致
  处理器在进行重排序时必须要考虑指令之间的数据依赖性
  多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测
  
  volatitle 实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象
   内存屏障（memory Barrier）：又称内存栅栏，是一个cpu指令，他的作用有两个：
      1，是保证特定操作的执行顺序
      2，是保证某些变量的内存可见性，（利用该特性实现，volatitle的内存可见性）
   由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令
    重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排优化，内存屏障另外一个作用是强制刷新处各种CPU的缓存数据，因此任何CPU上的线程
    都能读取到这些数据的最新版本
    对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存中
    对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
 volatile应用：
   单机版单例模式：
        private static  SingletonDemo instance = null;
    private  SingletonDemo(){
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo");
    }
    public  static SingletonDemo  getSingletonDemo(){
        if (instance==null){
            instance=new SingletonDemo();
        }
        return instance;
    }
  多线程下单例模式：DCL+volatile
     private static volatile  SingletonDemo instance = null;
    private  SingletonDemo(){
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo");
    }
    //DCL(double check lock双端检索机制)
    public  static SingletonDemo  getSingletonDemo(){
        if (instance==null){
            {
                synchronized(SingletonDemo.class){
                    if (instance==null){
                        instance=new SingletonDemo();
                    }
                }
            }
        }
        return instance;
    }

3. 面试题：CAS 是什么？ compareAndSwap 缩写  unsaf类（rd.jar包下的）+CAS思想（自旋）
       含义：比较并交换,比较当前工作内存中得值和主内存中得值，如果相同则执行规定操作，否则继续比较直到主内存和工作中得值一致为止
       应用：CAS有三个操作数，内存值V，旧得预期值A，要修改得更新值B
             当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做
       
     cas底层原理：如果知道谈谈unsafe类  
    1）Unsafe: 是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地方法（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作
       特定内存的数据，Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为java中CAS操作的执行依赖于Unsafe类的方法
    注意：Unsafe类中的所有方法都是native修改的，也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务
    2）变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的
    3）变量value用volatitle修饰，保证了多线程之间的内存可见性
       CAS的全称为Compare-And-Swap，它是一条CPU并发原语
       它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的
       CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法，调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。它是一种完全依赖于硬件的
       功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语
       的执行必须是连续的，在执行过程总不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题
       unsafe.getAndAddInt(Object var1,long var2,int var4)
       var1 AtomicInteger对象本身
       var2 该对象值得引用地址
       var4 需要变动得数量
       var5 是用过var1 var2找出得主内存中得真实的值
       用该对象当前的值和var5比较如果相同，更新var5+var4并且返回true，如果不容，继续取值然后再比较，直到更新完成
   CAS缺点：
        1，循环时间长，开销大（getAndAddInt方法执行时，有个do while，如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大的开销）
        2，只能保证一个共享变量的原子操作（当对一个变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，
                                        但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性）
        3.引出来ABA问题
   
AtomicInteger--> CAS-->Unsafe-->CAS底层思想-->（CAS缺点引出）ABA-->原子引用更新-->如何规避ABA问题
 4 面试题：原子类AtomicInterger的ABA问题谈谈，原子更新引用知道吗？    
       CAS会导致“ABA问题”
       CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差会导致数据的变化，比如说一个线程one从内存位置V
            取出A，这时候另一个线程two，也是从内存中取出A，并且two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候one进行CAS
            操作发现内存中仍是A，然后线程one操作成功
      ABA问题： 尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的
     AtmicReference 原子引用，对象类型的原子引用 
  ABA问题的解决： AtomicStampedReference     
      代码：
       static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);
    static  AtomicStampedReference atomicStampedReference= new AtomicStampedReference<>(100,1);

    public static void main(String[] args) {
        System.out.println("============以下是ABA问题的产生============");
        new Thread(()->{
            atomicReference.compareAndSet(100,101);
            atomicReference.compareAndSet(101,2019);

        },"t1").start();

        new Thread(()->{
            //暂停1秒，t2线程，保证t1线程完成一次ABA问题
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println( atomicReference.compareAndSet(100,2019)+"\t"+atomicReference.get());
        },"t2").start();
        //暂停一会线程
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("==============以下是ABA问题的解决==================");
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t第二次版本号"+atomicStampedReference.getStamp());
            atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t第3次版本号"+atomicStampedReference.getStamp());
        },"t3").start();

        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            //暂停3秒钟t4线程，保证上面的t3线程完成一次ABA操作
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            boolean result = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);
            System.out.println(Thread.currentThread().getName()+"\t修改成功否"+result+"\t当前最新实际版本号"+atomicStampedReference.getStamp());
            System.out.println(Thread.currentThread().getName()+"\t当前最新实际版本号"+atomicStampedReference.getReference());
        },"t4").start();
    }
  5面试题：集合类的不安全问题 ,如果是多线程情况下，会报java 
    ArrayList   当new ArrayList的时候默认容量为10，Arraylist的add方法没有加锁，所以线程不安全，vector的add方法加有synchronized，所以线程安全
           底层是object类型的数组
           1，new Vector()
           2,Collections.synchronizedList(new ArrayList<>())
           3,new CopyOnWriteArrayList<>()
           写时复制：
              CopyOnWrite容器即写时复制的容器，往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy,复制出一个新的容器
                 Object[] newElements ，然后新的容器Object[] newElements里添加元素，添加元素后，再将原容器的引用指向新的容器setArray(newElements),这样
                 做的好处是可以对CopyOnWriter容器进行并发得读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读
                 和写不同的容器
        源码:  public boolean add(E e) {
                    final ReentrantLock lock = this.lock;
                    lock.lock();
                    try {
                        Object[] elements = getArray();
                        int len = elements.length;
                        Object[] newElements = Arrays.copyOf(elements, len + 1);
                        newElements[len] = e;
                        setArray(newElements);
                        return true;
                    } finally {
                        lock.unlock();
                    }
                } 
    HashSet;是线程不安全的，它和ArrayList类似，它的底层是HashMap，初始16，负载因子0.75扽HashMap
            它的add方法对应put方法，put(key,PRESENT)),添加的时候，只看key,value为一个恒定的常量
            对应的juc里的安全类为：new CopyOnWriteArraySet<>()
    
    HashMap:是线程不安全的
           对应JUC里的new ConcurrentHashMap<>()
  6面试题：公平锁/非公平锁/可重入锁/递归锁/自旋 谈谈你的理解？请手写一个自旋锁     
         公平锁：是指多个线程按照申请锁的顺序来获取 锁，类似排队打饭，先来后到
         非公平锁： 是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成
                优先级反转或者饥饿现象
        公平锁/非公平锁
            并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁
        关于两者的区别：
           公平锁： Threads acqure a fair  lock in the order in which they requested  it
           公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是是等待队列的第一个，就占有锁
                 否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己
           非公平锁： a nonfair lock permists barging: threads requesting a lock  can jump ahead of  the  queue  of  waiting  threads if the 
                     lock happens to be  available  when  it is  requested
           非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就采用类似公平锁的那种方式
          java Reentrantlock而言
               通过构造函数指定该锁是否是否是公平锁，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大
          对于Synchronized而言，也是一种非公平锁
      可重入锁（也叫做递归锁）
        指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码
        在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁
        也即是说：线程可以进入任何一个它已经拥有锁所同步着的代码块
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
