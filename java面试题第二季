1，面试题：谈谈对volatitle关键字的理解
volatitle：是java虚拟机提供的轻量级的同步机制
  1, 保证可见性
  2，不保证原子性
  3，禁止指令重排
  多线程情况下，普通的变量是没有可见性的，加了volatile关键字可以保证可见性
如何解决原子性：加sync  ,使用juc下的AtomicInterger(底层是CAS)

2,面试题：JMM（java内存模型）你谈谈？
  硬盘<内存<cpu
   主内存：电脑内存，比如8g,16g
   自己的工作内存：比如每个线程从主内存中拷贝到各自线程的工作内存
   可见性：一个线程修改了主物理内存，其它线程也能看到
 JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规范或者规则，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式
   JMM关于同步的规定：
      1，线程解锁前，必须把共享变量的值刷新回主内存
      2，线程加锁前，必须读取主内存的最新值到自己的工作内存
      3，加锁解锁是同一把锁
   JMM要求：可见性，原子性，有序性   
    线程安全保证
   
      
  由于jvm运行程序的实体是线程，而每个线程创建时，JVM都会为其创建一个工作内存，（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而java
    内存模型中规定多有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将
     变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储
     着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成
     
     原子性指的是什么意思？不可分割，也即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整要么同时成功，要么同时失败
       number++在多线程下是非线程安全的
       
 计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分为三种
   源代码-》编译器优化的重排-》指令并行的重排-》内存系统的重排-》最终执行的指令
  单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致
  处理器在进行重排序时必须要考虑指令之间的数据依赖性
  多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测
  
  volatitle 实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象
   内存屏障（memory Barrier）：又称内存栅栏，是一个cpu指令，他的作用有两个：
      1，是保证特定操作的执行顺序
      2，是保证某些变量的内存可见性，（利用该特性实现，volatitle的内存可见性）
   由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令
    重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排优化，内存屏障另外一个作用是强制刷新处各种CPU的缓存数据，因此任何CPU上的线程
    都能读取到这些数据的最新版本
    对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存中
    对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
 volatile应用：
   单机版单例模式：
        private static  SingletonDemo instance = null;
    private  SingletonDemo(){
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo");
    }
    public  static SingletonDemo  getSingletonDemo(){
        if (instance==null){
            instance=new SingletonDemo();
        }
        return instance;
    }
  多线程下单例模式：DCL+volatile
     private static volatile  SingletonDemo instance = null;
    private  SingletonDemo(){
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo");
    }
    //DCL(double check lock双端检索机制)
    public  static SingletonDemo  getSingletonDemo(){
        if (instance==null){
            {
                synchronized(SingletonDemo.class){
                    if (instance==null){
                        instance=new SingletonDemo();
                    }
                }
            }
        }
        return instance;
    }

3. 面试题：CAS 是什么？ compareAndSwap 缩写  unsaf类（rd.jar包下的）+CAS思想（自旋）
       含义：比较并交换,比较当前工作内存中得值和主内存中得值，如果相同则执行规定操作，否则继续比较直到主内存和工作中得值一致为止
       应用：CAS有三个操作数，内存值V，旧得预期值A，要修改得更新值B
             当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做
       
     cas底层原理：如果知道谈谈unsafe类  
    1）Unsafe: 是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地方法（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作
       特定内存的数据，Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为java中CAS操作的执行依赖于Unsafe类的方法
    注意：Unsafe类中的所有方法都是native修改的，也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务
    2）变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的
    3）变量value用volatitle修饰，保证了多线程之间的内存可见性
       CAS的全称为Compare-And-Swap，它是一条CPU并发原语
       它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的
       CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法，调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。它是一种完全依赖于硬件的
       功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语
       的执行必须是连续的，在执行过程总不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题
       unsafe.getAndAddInt(Object var1,long var2,int var4)
       var1 AtomicInteger对象本身
       var2 该对象值得引用地址
       var4 需要变动得数量
       var5 是用过var1 var2找出得主内存中得真实的值
       用该对象当前的值和var5比较如果相同，更新var5+var4并且返回true，如果不容，继续取值然后再比较，直到更新完成
   CAS缺点：
        1，循环时间长，开销大（getAndAddInt方法执行时，有个do while，如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大的开销）
        2，只能保证一个共享变量的原子操作（当对一个变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，
                                        但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性）
        3.引出来ABA问题
   
AtomicInteger--> CAS-->Unsafe-->CAS底层思想-->（CAS缺点引出）ABA-->原子引用更新-->如何规避ABA问题
 4 面试题：原子类AtomicInterger的ABA问题谈谈，原子更新引用知道吗？    
       CAS会导致“ABA问题”
       CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差会导致数据的变化，比如说一个线程one从内存位置V
            取出A，这时候另一个线程two，也是从内存中取出A，并且two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候one进行CAS
            操作发现内存中仍是A，然后线程one操作成功
      ABA问题： 尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的
     AtmicReference 原子引用，对象类型的原子引用 
  ABA问题的解决： AtomicStampedReference     
      代码：
       static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);
    static  AtomicStampedReference atomicStampedReference= new AtomicStampedReference<>(100,1);

    public static void main(String[] args) {
        System.out.println("============以下是ABA问题的产生============");
        new Thread(()->{
            atomicReference.compareAndSet(100,101);
            atomicReference.compareAndSet(101,2019);

        },"t1").start();

        new Thread(()->{
            //暂停1秒，t2线程，保证t1线程完成一次ABA问题
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println( atomicReference.compareAndSet(100,2019)+"\t"+atomicReference.get());
        },"t2").start();
        //暂停一会线程
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("==============以下是ABA问题的解决==================");
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t第二次版本号"+atomicStampedReference.getStamp());
            atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t第3次版本号"+atomicStampedReference.getStamp());
        },"t3").start();

        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            //暂停3秒钟t4线程，保证上面的t3线程完成一次ABA操作
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            boolean result = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);
            System.out.println(Thread.currentThread().getName()+"\t修改成功否"+result+"\t当前最新实际版本号"+atomicStampedReference.getStamp());
            System.out.println(Thread.currentThread().getName()+"\t当前最新实际版本号"+atomicStampedReference.getReference());
        },"t4").start();
    }
  5面试题：集合类的不安全问题 ,如果是多线程情况下，会报java并发修改异常 
    ArrayList   当new ArrayList的时候默认容量为10，Arraylist的add方法没有加锁，所以线程不安全，vector的add方法加有synchronized，所以线程安全
           底层是object类型的数组
           1，new Vector()
           2,Collections.synchronizedList(new ArrayList<>())
           3,new CopyOnWriteArrayList<>()
           写时复制：
              CopyOnWrite容器即写时复制的容器，往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy,复制出一个新的容器
                 Object[] newElements ，然后新的容器Object[] newElements里添加元素，添加元素后，再将原容器的引用指向新的容器setArray(newElements),这样
                 做的好处是可以对CopyOnWriter容器进行并发得读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读
                 和写不同的容器
        源码:  public boolean add(E e) {
                    final ReentrantLock lock = this.lock;
                    lock.lock();
                    try {
                        Object[] elements = getArray();
                        int len = elements.length;
                        Object[] newElements = Arrays.copyOf(elements, len + 1);
                        newElements[len] = e;
                        setArray(newElements);
                        return true;
                    } finally {
                        lock.unlock();
                    }
                } 
    HashSet;是线程不安全的，它和ArrayList类似，它的底层是HashMap，初始16，负载因子0.75扽HashMap
            它的add方法对应put方法，put(key,PRESENT)),添加的时候，只看key,value为一个恒定的常量
            对应的juc里的安全类为：new CopyOnWriteArraySet<>()
    
    HashMap:是线程不安全的
           对应JUC里的new ConcurrentHashMap<>()
  6面试题：公平锁/非公平锁/可重入锁/递归锁/自旋 谈谈你的理解？请手写一个自旋锁     
         公平锁：是指多个线程按照申请锁的顺序来获取 锁，类似排队打饭，先来后到
         非公平锁： 是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成
                优先级反转或者饥饿现象
        公平锁/非公平锁
            并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁
        关于两者的区别：
           公平锁： Threads acqure a fair  lock in the order in which they requested  it
           公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是是等待队列的第一个，就占有锁
                 否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己
           非公平锁： a nonfair lock permists barging: threads requesting a lock  can jump ahead of  the  queue  of  waiting  threads if the 
                     lock happens to be  available  when  it is  requested
           非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就采用类似公平锁的那种方式
          java Reentrantlock而言
               通过构造函数指定该锁是否是否是公平锁，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大
          对于Synchronized而言，也是一种非公平锁
      可重入锁（也叫做递归锁）
        指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码；在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁
            也即是说：线程可以进入任何一个它已经拥有锁所同步着的代码块
        Synchronized/ReentrantLock 就是一个典型的可重入锁
        可重入锁最大的作用就是避免死锁（加锁要一对一对的加，如果new的锁多，关的少，就会卡死，如果new的少，关的多，则程序正常）
     自旋锁（spinlock)
       是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU（unsafe.getAndInt)
         //原子引用
              AtomicReference<Thread> atomicReference = new AtomicReference<>();

              public void mylock() {
                  Thread thread = Thread.currentThread();
                  System.out.println(Thread.currentThread().getName() + "\t come in ");
                  while (!atomicReference.compareAndSet(null, thread)) {

                  }
              }

              public void myUnloack() {
                  Thread thread = Thread.currentThread();
                  atomicReference.compareAndSet(thread, null);
                  System.out.println(Thread.currentThread().getName() + "\t invoked myunlock");
              }

              public static void main(String[] args) {
                  SingletonDemo singletonDemo = new SingletonDemo();
                  new Thread(() -> {
                      singletonDemo.mylock();
                      try {
                          TimeUnit.SECONDS.sleep(5);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      singletonDemo.myUnloack();
                  }, "AA").start();
                  try {
                      TimeUnit.SECONDS.sleep(1);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  new Thread(() -> {
                      singletonDemo.mylock();
                      try {
                          TimeUnit.SECONDS.sleep(5);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      singletonDemo.myUnloack();
                  }, "BB").start();
     独占锁（写锁）/共享锁（读锁）/互斥锁
       独占锁：指该锁一次只能被一个线程所持有，对ReentrantLock 和Synchronized而言都是独占锁
       共享锁：指该锁可被多个线程所持有
               对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁
       读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的
         多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。但是如果有一个线程想去写共享资源类，就不应该
         再有其它线程可以对该资源进行读或写
          小总结：读-读能共存
                  读-写不能共存
                  写-写不能共存
                 写操作：原子+独占
       读写锁案例（手写缓存）
               private volatile Map<String, Object> map = new HashMap<>();
                private ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();
                public void put(String key, Object value) {
                    rwlock.writeLock().lock();
                    try {
                        System.out.println(Thread.currentThread().getName() + "\t正在写入" + key);
                        TimeUnit.MILLISECONDS.sleep(300);
                        map.put(key, value);
                        System.out.println(Thread.currentThread().getName() + "\t写入完成");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                        rwlock.writeLock().unlock();
                    }
                }
                public void get(String key) {
                    rwlock.readLock().lock();
                    try {
                        System.out.println(Thread.currentThread().getName() + "\t正在读");
                        Object result = map.get(key);
                        System.out.println(Thread.currentThread().getName() + "\t读取完成:" + result);
                        TimeUnit.MILLISECONDS.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                        rwlock.readLock().unlock();
                    }
                }
                public static void main(String[] args) {
                    SingletonDemo singletonDemo = new SingletonDemo();
                    for (int i = 0; i < 5; i++) {
                        final int tempInt = i;
                        new Thread(() -> {
                            singletonDemo.put(tempInt + "", tempInt + "");
                        }, String.valueOf(i)).start();

                    }
                    for (int i = 0; i < 5; i++) {
                        final int tempInt = i;
                        new Thread(() -> {
                            singletonDemo.get(tempInt + "");
                        }, String.valueOf(i)).start();

                    }
    CountDownLatch: 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒（班长锁门）
                    CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞，其它线程调用countDown方法会将计数器减一
                    （调用countDown方法的线程不会阻塞）当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行
    CyclicBarrier: CyclicBarrier的字面意思是可循环（Cyclic)使用的屏障（Barrier)，它要做的事情是让一组线程达到一个屏障（也可以叫同步点）时被阻塞
                  直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法（人到齐开会/收集七龙珠）
    Semaphore: 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制（争车位）
面试题：阻塞队列知道吗？
   队列+阻塞队列：
      当阻塞队列是空的时候，从队列种获取元素的操作将会被阻塞
      当阻塞队列是满的时候，往队列里添加元素的操作会被阻塞
    在多线程领域:所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足被挂起的线程又会自动被唤醒
     为什么需要BlickingQueue
       好处是我们不需要关系什么时候需要阻塞线程，什么时候需要唤醒线程，因为着一切BlockingQueue都给你包办了
       在concurrent包发布以前，多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度
      BlockingQueue是Collection下的接口
         #ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列FIFO（先进先出）原则对元素进行排序
         #linkedBlockingQueue:一个基于链表结构的阻塞队列（大小默认值为Integer.MAX_VALUE）阻塞队列，此队按照FIFO（先进先出）排序元素，吞吐量通常要高于ArrayBlockingQueue
         #SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高，每一个put操作，总要等待一个take操作
         PriorityBlockingQueue：支持优先级排序的无界阻塞队列                                                                                                                               
         DelayQueue:使用优先级队列实现的延迟无界阻塞队列
         LinkedTransferQueue:由链表结构组成的无界阻塞队列
         LinkedBlockingDeque:由链表结构组成的双向阻塞队列
       BlockingQueue的核心方法：
        方法类型    抛出异常     特殊值     阻塞     超时
        插入        add(e)      offer(e)   put(e)   offer(e,time,unit)
        移除        remove()     poll()    take()   poll(time,unit)
        检查        element()    peek()    不可用   不可用
        抛出异常 ：当阻塞队列满时，再将队列里add插入元素会抛出IllegalStateException：Queue full
                   当阻塞队列空时，再往队列里remove,移除元素会抛出NoSuchElementException
        特殊值： 插入方法，成功为true,失败false
                 移除方法，成功返回处队列的元素，队列里面没有就返回null
        一直阻塞：当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产线程直到put数据or相应中断退出
                 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用
        超时退出：当阻塞队列满时，队列会阻塞生产者线程一定时间，超过后限时后生产者线程会退出       
   阻塞队列用在哪里？
      生产者消费之模式
             （多线程判断要用while判断）
      资源类：
              private volatile boolean  FLAG = true;
               private AtomicInteger atomicInteger = new AtomicInteger();
                BlockingQueue<String> blockingQueue=null;
               public Test(BlockingQueue<String> blockingQueue){
                   this.blockingQueue= blockingQueue;
                   System.out.println(blockingQueue.getClass().getName());
               }
               public void pro() throws Exception{
                   String data=null;
                   while (FLAG){
                       data = atomicInteger.getAndIncrement()+"";
                       boolean reValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
                       if (reValue){
                           System.out.println(Thread.currentThread().getName()+"\t插入队列"+data+"成功");
                       }else {
                           System.out.println(Thread.currentThread().getName()+"\t插入队列"+data+"失败");
                       }
                       TimeUnit.SECONDS.sleep(1);
                   }
                   System.out.println(Thread.currentThread().getName()+"\t 大老板叫停，表示Flag=false,生产动作结束");

               }
               public void consume() throws Exception{
                   String result=null;
                   while (FLAG){
                       result = blockingQueue.poll(2L, TimeUnit.SECONDS);
                       if (null==result||result.equalsIgnoreCase("")){
                          FLAG = false;
                           System.out.println(Thread.currentThread().getName()+"\t超过两秒没收到蛋糕，消费退出");
                           System.out.println();
                           System.out.println();
                           return;
                       }
                       System.out.println(Thread.currentThread().getName()+"\t消费队列"+result+"成功");
                   }


               }
               public void stop(){
                   this.FLAG = false;
               }
   测试类：
               public static void main(String[] args) {
                    Test test = new Test(new ArrayBlockingQueue<>(10));
                    new Thread(()->{
                        System.out.println(Thread.currentThread().getName()+"\t 生产者线程启动");
                        try {
                            test.pro();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    },"prod").start();
                    new Thread(()->{
                        System.out.println(Thread.currentThread().getName()+"\t 消费者线程启动");
                        try {
                            test.consume();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    },"consume").start();
                    try {
                        TimeUnit.SECONDS.sleep(5);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println();
                    System.out.println();
                    System.out.println();
                    System.out.println("5秒钟时间到，大老板main线程叫停活动结束;");
                    test.stop();
                }
             
      线程池
      消息中间件
       
    callable接口有返回值，runable接口没有返回值，futureTask是有有实现callable接口的构造入参，和实现runable接口
      多个线程抢一个futureTask，只会调用一次futureTask 
   线程池做的工作主要是可控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出了数量的线程
      排队等候，等其它线程执行完毕，再从队列中取出任务来执行
      它的主要特点：线程复用，控制最大并发数，管理线程
        第一：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗
        第二：提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行
        第三：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
   java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors,ExecutorService,ThreadPoolExecutor这几个类
      了解：
        Executors.newScheduledThreadPool()   时间调度
        Executors.newWorkStealingPool(lnt) java8新增   使用目前机器上可用的处理器作为它的并行级别
      重点：
        Executors.newFixedThreadPool(int)
           底层实现：
            public static ExecutorService newFixedThreadPool(int nThreads) {
            return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
            }
           主要特点：
              1，创建一个定长线程池，可控制线程最大并发数，超出的线程会再队列中等待
              2，newFixedThreadPool创建的线程池corePoolSize和maxmumPoolSize值是相等的，它使用的LinkedBlockingQueue
         Executors.newSingleThreadExecutor()
            底层实现：
                  public static ExecutorService newSingleThreadExecutor() {
                  return new FinalizableDelegatedExecutorService
                      (new ThreadPoolExecutor(1, 1,
                                              0L, TimeUnit.MILLISECONDS,
                                              new LinkedBlockingQueue<Runnable>()));
                  }
             主要特点：
               1，创建一个单线程化的线程池，它只会中唯一的工作线程来执行任务，保证所有任务按照指定顺序执行
               2，newSingleThreadExecutor将corePoolSize和maxmumPoolSize都设置为1，它使用的LinkedBlockingQueue        
        Executors.newwCachedThreadPool()
             底层实现：
                   public static ExecutorService newCachedThreadPool() {
                    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                                  60L, TimeUnit.SECONDS,
                                                  new SynchronousQueue<Runnable>());
                    }
             主要特点：
                1，创建要给可缓存线程池，如果线程池长度超过处理需要，可灵活回收线程，若无可回收，则新建线程
                2，newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Interger.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行
                    当线程空闲超过60秒，就销毁线程

     生产上这三种一个都不用，阿里巴巴java开发手册上的，
            不允许显式创建线程
           线程池不允许使用Excutors,而是通过ThreadPooleExecutor的方式，这样的处理方式，更加明确线程池的运行规则，规避资源耗尽的风险

     线程池的七大参数：
        1，corePoolSize:线程池中常驻核心线程数
             在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解 为今日当值线程
             当线程池中的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中
        2，maximumPoolSiz:线程池能够容纳同时执行的最大线程数，此值必须大于等于1
        3，keepAliveTime：多余的空闲线程的存活时间，
             当前线程池数量超过corePoolSize时，当空闲线程达到KeepAliveTime值时，多余空闲线程会被销毁，直到只剩下corePoolSize个线程为止
               默认情况下，只有当线程池数大于corePoolSize时keepAliveTime才会起作用，直到线程池的线程数据不大于corePoolSize
        4，unit：keepAliveTime的单位
        5，workQueue：任务队列，被提交但尚未执行的任务
        6，threadFactory :表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可
        7，handle:拒绝策略，表示当队列满了，并且工作线程大于等于线程的最大线程数
             （等待队列满了，再也塞不下新任务，同时线程池的Max线程也达到了，无法继续为新任务服务，这时候我们需要拒绝策略机制合理处理这个问题）
            AbortPolicy （默认）：直接抛出RejectedExecutionException异常阻止系统正常运行
            DiscardPolicy ：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者
            CallerRunsPolucy ：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务
            DiscardOldesPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种方案
         以上策略均实现了RejectedExecutionHandler接口
      线程池的底层工作原理：
         1，在创建了线程池后，等待提交过来的任务请求
         2，当调用execute()方法添加一个请求任务时，线程池会做如下判断，
             2.1  如果正在运行的线程数小于corePoolSize，那么会马上创建线程运行这个任务
             2.2  如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
             2.3  如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立即运行这个任务
             2.4  如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行
         3，当一个线程完成任务时，它会从队列中取下一个任务来执行
         4，当一个线程无事可做超过一定的时间（keepAliveTime）时线程池会判断：
                如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉
                所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小
    合理配置线程池你是如何考虑的？
      CPU密集型 ：密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直全速运行，CPU密集任务只有在这正的多核CPU上才可能得到加速（通过多线程）
                  而在单核CPU上，无论开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些
                  CPU密集型任务配置尽可能少的线程数量，一般公式：CPU核数+1个线程的线程池
         
      io密集型：1 .由于io密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如CPU核数*2
                2 .io密集型，即该任务需要大量的io，即大量阻塞
                   在单线程上运行io密集型的任务会导致浪费大量的CPU运算能力浪费在等待
                   所以在io密集型任务中，使用多线程可以大大的加速程序运行，即使在单核CPU上，这种加速主要就是利用了被浪费调的阻塞时间
                   io密集型时，大部分线程都阻塞，故需要多配置线程数：
                       参考公式：CPU核数/（1-阻塞系数）    阻塞系数在0.8~0.9之间
                          比如8核CPU：8/（1-0.9）=80个线程数
               获取CPU核数：Runtime.getRuntime().availableProcessors()
   死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成一种互相等待的现象，若五外力干涉那他们都将无法推进下去，如果系统资源充足，进程的资源
          请求都能够满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁
          linus下查看进程； ps -ef|grep xxxx ls -l
          jsp: windows下的查看java进程 jsp -l 找到出问题的进程号比如9636
          jstack:   查看原因    例：jstack 9636
          
       产生死锁的原因：
           系统资源不足，进程运行推进的顺序不合适，资源分配不当
       解决：jps命令定位进程号
             jstack 找到死锁查看
  jvm垃圾回收的时候如何确定垃圾？是否知道什么是GC Roots
     什么是垃圾？ 简单的说就是内存中已经不再被使用到的空间就是垃圾
     要进行垃圾回收，如何判断一个对象是否可以被回收？
         引用计数法：java中引用和对象是有关联的，如果要操作对象则必须要引用进行
                   因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收，简单说，给对象添加一个引用计数器
                        每当有一个地方引用它，计数器值加1
                        每当有一个引用失效时，计数器值减1
                   任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象
                   那为什么主流的java虚拟机里面都没有选用这种算法？其中最主要的原因是很难解决对象之间相互循环引用的问题（该算法存在但目前无人用了）
         枚举根节点做可达性分析（根搜索路径）
            为了解决引用计数法的循环引用问题，java使用了可达性分析的方法
              所谓‘GC roots’或者说tracing GC的‘根集合’就是一组必须活跃的引用
              基本思路就是通过一系列名为'GC Roots'的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用，
                  也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有遍历到的就自然被判定死亡                                                                                                                                    
           哪些可以作为GC Roots的对象?
                虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象
                方法区中类类静态属性引用的对象
                方法区中常量引用的对象
                本地方法栈中JNI(Native方法）引用的对象
    jvm调优和参数配置，如何盘点查看JVM系统默认值 
         jvm的参数类型： 标配参数    -version   -help    java -showversion
                         x参数（了解） -Xint 解释执行
                                       -Xcomp  第一次使用就编译成本地代码
                                       -Xmixed  混合模式
                         xx参数 Boolean类型    公式：   -xx: +或者-某个属性值
                                                            +表示开启  - 表示关闭
                                              case:是否打印GC收集细节  -XX:-PrintGCDetails     -XX:+PrintGCDetails
                                                   是否使用串行垃圾回收器 -XX:-UseSerialGC      -XX:+UserSerialGC
                                kv设值类型    公式:  -XX:属性key=属性value
                                              case:  -XX:MetaspaceSize=128m  （默认值21M左右）   -XX:MaxTenuringThreshold=15（对象被复制的次数默认15）
                                jinfo例子：   jsp -l 查看进程号      jinfo -flag PrintGCDetails 进程号  查看运行程序的配置
                        查看当前运行程序的配置： 公式：  jinfo -flags 配置项进程编号          jinfo -flags 5988
                                                 case1: jinfo -flag InitialHeapSize 8372  初始化堆大小
                                          
                        两个经典参数： -Xms等价于-XX:InitialHeapSize（默认物理内存的64分之一）                 -Xmx等价于-XX:MaxHeapSize(默认物理内存的四分之一)
                                       Xss初始栈空间大小
                        
        盘点家底查看jvm默认值:  -XX:+PrintFlagsInitial   主要查看初始默认
                                                         公式： java -XX:+PrintFlagsInitial -version
                                                                java -XX:+PrintFlagsInitial
                               -XX: +PrintFlagsFinal    主要查看修改更新  =代表没有修改过，  ：= 代表jvm修改过或者人为修改过的
                                                        公式： java -XX:+PrintFlagsFinal -version
                                                     PrintFlagsFinal举例，运行java命令的同时打印出参数   java -XX:+PrintFlagsFinal -Xss128k 运行java类的名字
                              -XX：+PrintCommandLineFlags   公式： java -XX:+PrintCommandLineFlags -version  主要查看GC的算法
               System.out.println(Runtime.getRuntime().availableProcessors());  查看本机线程数
               System.out.println(Runtime.getRuntime().maxMemory());            java虚拟机试图使用的最大内存量
               System.out.println(Runtime.getRuntime().totalMemory());           java虚拟机中的内存总量
               
               -XX:+UseSerialGC  串行垃圾回收器
               -XX:+UseParallereGC   并行垃圾回收器
              
   平时工作用过的jvm常用基本配置参数有哪些？
                 -Xms   : 初始大小内存，默认为物理内存的1/64，等价于-XX:InitialHeapSize
                 -Xmx   :最大分配内存，默认为物理内存的1/4，等价于-XX:MaxHeapSize
                 -Xss   :设置单个线程栈的大小，一般默认为512k~1024k，等价于-XX:ThreadStackSize
                 -Xmm   :设置年轻代的大小
                 -XX:MetaspaceSize 设置元空间大小      元空间的本质和永久代类似，都是对JVM规范中方法区的实现，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存  因此默认情况下(21m)，元空间的大小仅受本地内存限制
                                   -Xms10m -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal                    
                                  经典配置：-Xms128m -Xmx4096m -Xss1024k -XX：MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC                         
                 -XX:PrintGCDetails   输出详细GC收集日志信息
                                      GC
                                      FullGC  规律：名称 GC前内存占用  GC后内存占用  该区内存总大小
                 -XX:SurvivorRatio    设置新生代中eden和SO/S1空间的比例
                                      默认：  -XX:SurvivorRatio=8,Eden:SO:S1=8:1:1
                                      假如：-XX:SurvivorRatio=4,Eden:SO:S1=4:1:1
                                           SurvivorRatio 值就是设置eden区的比例占多少，SO/S1相同
                                      参数配置：-XX:+PrintGCDetails -XX:+UserSerialGC -Xms10m -Xmx10m -XX:SurvivorRatio=4
                 -XX:NewRatio         配置年轻代和老年代在堆结构的占比
                                      默认： -XX:NewRatio=2新生代占1，老年代占2，年轻代占整个堆的1/3
                                      假如： -XX：NewRatio=4新生代占1，老年代占4，年轻代占整个堆的1/5，NewRatio值就是设置老年代的占比，剩下的1给新生代
                                             命令：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UserSerialGC -XX:NewRatio=2
                 -XX:MaxTenuringThreshold    设置：垃圾的最大年龄
                                                  查看默认进入老年代年龄：  jinfo -flag MaxTenuringThreshold 进程编号
                                             如果设置为0的话，则年轻对象不经过Survivor区，直接进入年老代，对于年老代比较多的应用，可以提高效率
                                             如果设置为一个较大的值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的概论，java8设置为0~15
 强引用，软引用，弱引用，虚引用分别是什么？                                            
           整体架构 java lang ref  包下   Object--Reference---SoftReference,WeakReference,PhantomReference    
           强引用（默认支持模式）：当内存不足，jvm开始垃圾回收，对于强引用对象，就算是出现了OOM也不会对该对象进行垃圾回收，死都不收
                                  强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表名对象还“活着”，垃圾收集器不会碰这种对象。在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能
                                  被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收，因此强引用是造成java内存泄漏的主要原因之一
                                  对于一个普通的对象，如果没有其它的引用关系，只要超过了引用作用域或者显式地将相应强引用赋值为null,一般认为就是可以被垃圾收集的了（当然具体回收时机还要看垃圾收集策略）
           软引用： 软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集
                          对于只有软引用的对象来说，当系统内存充足时，它不会被回收，当系统内存不足时，它会被回收 
                          软引用通常用来对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收
                    应用场景：缓存的设计思路： Map<String,SoftReference<Bitmap>> imageCache = new HashMap<String ,SoftReference<Bitmap>>();用于需要加载大量图片;mybatis底层也用到软引用
                    你知道弱引用的话，能谈谈WeakHashMap吗？
           弱引用：  弱引用需要用到java.lang.ref.WeakReference类来实现，它比软引用的生存期更短
                     对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管jvm的内存空间是否足够，都会回收该对象占用的内存
           虚引用：虚引用需要java.lang.ref.PhantomReference类来实现   监控对象的回收情况
                        顾名思义，就是形同虚设，与其他几种引用不同，虚引用并不会决定对象的生命周期
                        如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能别垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueue）联合使用
                        虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅是提供了一种确保对象被finalize以后，做某些事情的机制
                        PhantomReference的get方法总是返回null，因此无法访问对应的引用对象，其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作
                        换句话说，设置虚引用关联的唯一目的，就是在这个对象被垃圾回收的时候收到一个系统通知或者后续添加进一步的处理
                        java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作
                   引用队列
                     java提供了4种引用类型，在垃圾回收的时候，都有自己各自的特点，ReferecnceQueue是用来配合引用工作的，都有各自的特点
                        RefereceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行
                        创建引用的时候可以指定关联队列，当GC释放对象内存的时候，会将引用加入到引用队列
                        如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于一种通知机制
                        当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收，通过这种方式，jvm允许我们在对象被销毁后，做一些我们自己想做的事情
 请谈谈你对OOM的认识：java.lang.StackOverflowError (方法里调自己会出现,递归调用) 是一个错误error
                     java.lang.OutOfMemoryError:java heap space（不断地new对象，new 大字节数组会出现）        是一个错误error
                     java.lang.OutOfMemoryError:GC overhead limit exceeded（98%的时间用来做GC，并且回收了不到2%的堆内存，cpu使用率一直都是100%，而GC却没有任何成效）
                     java.lang.OutOfMemoryError:Direct buffer memory
                         在本地内存new对象，GC管不到，当本地用光了，再次尝试分配本地内存，就报这个错误
                         导致原因： 写NIO程序经常使用ByteBuffer来读取或写入数据，这是一种基于通道（channel）与缓冲区（buffer）的I/O方式
                                    它可以使用Native函数库直接分配堆外内存，然后通过一个存储在java堆里面的DirectByteBuffer对象作为这块内存的引用进 
                                     行操作，这样能在一些场景中显著提高性能，因为避免了在java堆和Native堆中来回复制数据
                                     ByteBuffer.allocate(capability) 第一种是分配jvm内存，数据GC管辖方位，由于需要拷贝所以速度相对较慢
                                     ByteBuffer.allocateDirect（capability)第二种是分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝所以速度相 
                                     对较快
                                    但如果不断分配本地内存，堆内存很少使用，那么jvm就不需要执行GC,DirectByteBuffer对象就不会被回收
                                    这时候堆内存充足，但本地内存可能已经用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接崩溃了

                     java.lang.OutOfMemoryError:unable to create new native thread
                          高并发请求服务器是，经常出现这个问题，准确的讲该native thread异常与对应平台有关
                          导致原因： 1，你的应用创建太多线程了，一个应用进程创建多个线程，超过系统承载极限
                                     2，你的服务器并不允许你的应用程序创建这么多线程，linux系统默认允许单个线程可以创建的线程数是1024个
                                     你的应用创建超过这个数量，就会报java.lang.OutOfMemoryError：unable to create new native  thread
                          解决办法：1，想办法降低你的应用创建程序的数量，分析应用是否真的需要创建这么多线程，如果不是，改代码将线程数降到最低
                                    2，对于有的应用，确实需要创建很多线程，远超过Linux系统的默认1024个线程的限制，可以通过修改linux服务器配置，扩大linux默认限制  命令：ulimit -u查看非root用户的最大线程数，root默认无限制        
                     java.lang.OutOfMemoryError:Metaspace
                                java8及以后的版本使用Metaspace来代替永久代，Metaspace是方法区在HotSpot中的实现，它与持久代最大的区别在于： Mettaspace并不在虚拟机内存中而是使用本地内存，也即在java8中，class metadata(the virtual internal presentation of java class ),被存储在叫做
                                Metaspace的native memory
                                永久代 （java8后被元空间Metaspace取代了）存放了以下信息
                                  虚拟机加载的类信息，常量池，静态变量，即时编译后的代码
                                  模拟Metaspace空间溢出，我们不断生成类往元空间灌，类占据的空间总是会超过Metaspace指定的空间大小的
      GC垃圾回收算法和垃圾收集器的关系？分别是什么？请你谈谈？
           GC算法（引用计数/复制/标清/表整）是内存回收的方法论，垃圾收集器就是算法落地实现
           因为目前为止还没有完美的收集器出现，更加没有万能的收集器，只是针对具体应用最合适的收集器，进行分代收集
           四种主要的垃圾收集器：
               Serial（串行垃圾回收器） 它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，所以不适合服务器环境    
               Parallel（并行垃圾回收器） 多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理首台处理等弱交互场景
               CMS（ConcMarkSweep  并发标记清除   并发垃圾回收器）  用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行）不需要停顿用户线程，互联网公司多用它，适用对相应时间有要求的场景
               G1（java8默认）  G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收
               ZGC(java 11以后）
              
      
      怎么查看服务器默认的垃圾收集器是哪个？生产上如何配置垃圾收集器的？谈谈你对垃圾收集器的理解？
        java -XX:+PrintCommandLineFlags -version
        java的GC回收类型主要有几种：UserSerialGC ,UserParallelGC,UseConcMarkSweepGC,UseParNewGC,UseParallelOldGC,UseG1GC
           Young Gen : Serial Copying    Parallel Scavenge   ParNew
                                                                                                 G1         
           Old   Gen: Serial  MSC(Serial Old)  Parallel Compacting(Parallel Old)  CMS
              垃圾收集器就来具体实现这些GC算法并实现内存回收，不同厂商，不同版本的虚拟机实现差别很大，HotSpot中包含的收集器
        新生代： 串行GC(Serial)/(Serial Copying) 一个单线程的收集器，在进行垃圾收集时候，必须暂停其它所有的工作线程直到它收集结束，
                     简单高效，对于单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器
                     对应的JVM参数是： -XX:+UseSerialGC
                       开启后会使用： Serial(Young区用）+Serial Old(Old区用）的收集器组合
                       表示：新生代，老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法
                          -Xms 10m -Xms10m -XX:+PrintGCDetails -XX:+UseSerialGC
                 并行GC(ParNew) 使用多线程进行垃圾回收，在垃圾收集时，会Stop-the-World暂停其它所有的工作线程直到它收集结束
                               ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，ParNew垃圾收集器完全一样
                               ParNew收集器在垃圾收集过程中同样也要暂停所有其它的工作线程，它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器
                               常用对应的JVM参数： -XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代
                               开启上述参数后，会使用ParNew（Young区用）+Serial Old 的收集器组合，新生代使用复制算法，老年代采用标记——整理算法
                               备注： -XX: ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数
                 并行回收GC(Parallel)/(Parallel Scavenge)   Parallel Scavenge 收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器，一句话：串行收集器在新生代老年代的并行化
                                                           它关注的重点是： 
                                                             可控制的吞吐量（Thoughput = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）），也即比如程序运行100分钟，垃圾收集1分钟，（吞吐量就是99%），高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务
                                                             自适应调节策略也是ParallelScavenge 收集器与ParNew 收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大的吞吐量
                                                             常用JVM参数： -XX:+UseParallelGC或-XX:+UseParallelOldGC(可互相激活）使用Parallel Scanvenge收集器
                                                             开启该参数后：新生代使用复制算法，老年代使用标记-整理算法
                                                             -XX:ParallelGCThreads=数字N  表示启动了多少个GC线程
                                                             cpu>8 N=5/8   CPU<8  N=实际个数
       老年代： 串行GC(Serial Old)/(Serial MSC):  是Serial垃圾收集器老年代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器
                                                在Server模式下，主要有两个用途（了解，版本已经到8以后）：
                                                      1，在jdk1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用，（Parallel Scavenge + Serial Old)
                                                      2,作为老年代版中使用CMS收集器的后备垃圾收集方案
                并行GC(Parallel Old)/(Parallel MSC)  Parallel Old 收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old 收集器在jdk1.6才开始提供
                                                    在jdk1.6之前，新生代使用ParallelScavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，在JDK1.6之前（Parallel Scavenge+ Serial Old）
                                                    Parallel Old 正事为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统堆吞吐量要求比较高，jdk1.8后可以优先考虑新生代Parallel Scavenge和年老代Parlllel Old收集器的搭配策略，在JDK1.8后，（Parallel Scavenge+Parallel Old)
                                                    jvm常用参数：-XX:+UseParallelOldGC 使用Parallel Old 收集器，设置该参数后，新生代Parallel +老年代 Parallel Old
                并发标记清除GC(cms)  CMS收集器是一种以获取最短回收停顿时间为目标的收集器，适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短
                                     CMS非常适合堆内存大，CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器，并发标记清除收集器组合： ParNew+CMS+Serial Old 
                                     Concurrent Mark Sweep 并发标记清除，并发收集低停顿，并发值得是与用户线程一起执行
                                      开启该收集器的jvm参数： -XX: +UseConcMarkSweepGC  开启该参数后会自动将 -XX: +UseParNewGC打开
                                      开启该参数后，使用ParNew(Young区用)+CMS(Old区用)+Serial  Old收集器组合，Serial Old 将作为CMS出错后的后备收集器
                            四步过程： 初始标记（CMS initial mark）    只是标记一下GC Root 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程
                                       并发标记（CMS concurrent mark) 和用户线程一起  进行GC Roots跟踪的跟踪过程，和用户线程一起工作，不需要暂停工作线程，主要标记过程，标记全部对象
                                       重新标记（CMS remark） 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程，由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正
                                       并发清除（CMS concurrent sweep)和用户线程一起， 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程，基于标记结果，直接清理对象
                                                                                    由于耗时最长的并发标记和并发清除过程中，垃圾回收线程可以和用户现在一起并发工作，所以总体上来看，CMS收集器的内存回收和用户线程一起并发地执行
                            优点：        并发收集低停顿
                            缺点： 并发执行,对CPU资源压力大： 由于并发进行，CMS在收集与应用线程会同时会增加对堆内存的占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将会触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间
                                  采用的标记清除算法会导致大量碎片  ：标记清除算法无法整理空间碎片，老年代空间会随着应用时长逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩，CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，
                                   进行一次压缩的FUll GC 
      如何选择垃圾收集器：
                       组合的选择： 单CPU或小内存，单机程序 
                                       -XX:+UseSerialGC
                                   多CPU,需要最大吞吐量，如后台计算型应用
                                        -XX:+UseParallelGC 或者  -XX:+UseParalllelOldGC
                                   多CPU，追求低停顿时间，需快速相应如互联网应用
                                        -XX:+UseCocMarkSweepGC -XX:+ParNewGC
                                        
                   以前收集器的特点：年轻代和老年代是各自独立且独立且连续的内存块
                                     年轻代收集使用单eden+S0+S1进行复制算法
                                     老年代收集必须扫描整个老年代区域
                                     都是以尽可能少而快速的执行GC为设计原则
                   G1是什么？ G1（Garbage-First）收集器，是一款面向服务端应用的收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求，
                               另外它还具有以下特性： 像CMS收集器一样，能与应用程序线程并发执行，整理空闲空间更快，需要更多的时间来预测GC停顿时间，不希望牺牲大量的吞吐性能，不需要更大的java Heap
                               G1收集器的设计目的是取代CMS收集器，它同CMS相比，在以下方面表现得更出色：
                                          G1是一个有整理内存过程得垃圾收集器，不会产生很多内存碎片
                                          G1得Stop The World（STW）更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间
                               CMS垃圾收集器虽然减少了暂停应用程序得运行时间，但是它还是存在内存碎片问题，于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，java7发布了一个新的垃圾收集器-G1垃圾收集器
                               G1是在2012年才在jdk1.7u4 中可用，oracle官方计划在jdk9中将G1变成默认得垃圾收集器以替代CMS,它是一款面向服务端应用得收集器，主要应用在CPU和大内存服务器环境下，极大得减少垃圾收集得停顿时间，全面提升服务器得性能，逐步替换JAVA8以前得CMS收集器
                               主要改变时Eden，Survivor和Tenured等内存区域不再是连续得了，而是变成一个个大小一样得regin,每个region从1M到32M不等，一个region有可能属于Eden,Surivor或者Tenured内存区域
      G1垃圾收集器： 特点： 1，G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW
                           2，G1整体上采用标记-整理算法，局部是通过复制算法，不会产生内存碎片
                           3，宏观上看G1之中不再区分年轻代和老年代，把内存划分成多个独立得子区域（Region）可以近似理解为一个围棋得棋盘
                           4，G1收集器里面将整个得内存区都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代区分，保留了新生代和老年代，但他们不再是物理隔离得，而是一部分Region得集合且不需要Region是连续得，也就是说依然会采用不同得GC方式来处理不同得区域
                           5，G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代得区别，也不需要完全独立得surivvor（to space)堆做复制准备，G1只有逻辑上的分代概念，或者说每个分区都可能随着G1得运行在不同代之间前后切换
                     底层原理： Region区域化垃圾收集器    最大化好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可
                                                         区域化内存划片Region,整体编为了一系列不连续的内存区域，避免了全内存的GC操作
                                                         核心思想是将整个堆内存区域分为大小相同的子区域（Region)，在jvm启动时会自动设置这些子区域的大小
                                                     在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续的即可，每个分区也不会固定的为某个代服务，可以按需在年轻代和老年代之间切换，启动时可以通过参数-XX:+G1HeapRegionSize=n 可指定分区大小（1MB~32MB,且必须是2的幂）
                                                       默认将整堆划分为2048个分区，大小在1MB~32MB,最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048=65536MB=64G内存
                                                 G1算法将堆划分为若干个区域（Region),它仍然属于分代收集器
                                                    这些Region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间
                                                    这些Region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样就不会有CMS内存碎片问题的存在了
                                                    在G1中，还有一个特殊的区域，叫Humongous(巨大的)区域，如果一个对象占用的空间超过了分区容量50%以上，G1收集器就认为这是一个巨型对象。这些巨型对象默认直接会被分配到年老代，但是如果它是一个短期存在的巨型对象，就会堆垃圾收集器造成负面影响，
                                                    为了解决整个问题，G1划分了一个Humongous区，它用来专门存放巨型对象，如果一个H区装不下一个巨型对象，那么会寻找连续的H分区来存储，为了能找到连续的H区，有时候不得不启动FULL gc
                                                    
                                                    
                                回收步骤  G1收集器下的Young GC
                                           针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片
                                              Eden区的数据移动到Surivivor区，假如出现Survivor区空间不够，Eden区数据部分会晋升到Old区
                                              Survivor区的数据移动到新的Survivor区，部分数据会晋升到Old区，最后Eden区收拾干净了额，GC结束，用户的应用程序继续执行
                                4步过程  初始标记： 只标记GC Roots能直接关联到的对象
                                         并发标记： 进行GC Roots Tracting 的过程
                                         最终标记： 修正并发标记期间，因程序运行导致标记发生变化的那一部分对象
                                         筛选回收：根据时间来进行价值最大化回收
                     常用配置参数（了解） :-XX:+UseG1GC
                                          -XX:G1HeapRegionSize=n:设置的G1区域的大小，值是2的幂，范围是1MB到32MB，目标是根据最小的java堆大小分出约2048个区域
                                          -XX:MaxGCPauseMillis=n: 最大GC停顿时间，这个是个软目标，jvm将尽可能（但不保证）停顿小于这个时间
                                          -XX:InitiatingHeapOccupancyPercent=n:堆占用了多少就触发GC，默认为45
                                          -XX:ConcGCThreads=n 并发GC使用的线程数
                                          -XX:G1ReservePercent=n:设置作为空闲空间的预留百分比，以降低目标空间溢出的风险，默认值是10%
                             开发人员仅仅需要声明：开始G1+设置最大内存+设置最大停顿时间
                                               -XX:+UseG1GC  -Xmx32g -XX:maxGCPauseillis=100
                  比起cms有两个优势：
                     1） G1不会产生内存碎片
                     2） 是可以精确控制停顿，该收集器是把整个堆（新生代，老年代）划分为多个固定大小的区域，每次根据允许停顿的时间区收集垃圾最多的区域
       jvmGC+SpringBoot微服务的生产部署和调参优化，实际工作中，如何结合Springboot进行调优？  
         1，idea开发完微服务工程
         2，maven进行clean package
         3,要求微服务启动时候，同时配置我们的JVM/GC的调优参数
            3.1内
            3.2外==》重点
        4，公式
            Java -server jvm的各种参数  -jar 第一步上面的jar/war包名字
  生产服务器变慢，诊断思路和性能评估谈谈？     
       整机：top
       cpu:vmstat   vmstat -n 2 3
           查看CPU(包含不限于)
                一般vmstat工具的使用是通过两个数字参数来完成的，第一个是采样的时间间隔单位是秒，第二个参数是采样的次数
                -procs
                   r: 运行和等待CPU时间片的进程数，原则上1核的cpu的运行队列不要超过2，整个系统的运行队列不能超过总核数的2倍，否则代表系统压力过大
                   b: 等待资源的进程数，比如正在等待磁盘I/O,网络I/O等
                -CPU:
                   us:用户进程消耗CPU时间百分比，us值高，用户进程消耗CPU时间多，如果长期大于50%，优化程序
                   sy:内核进程消耗的CPU时间百分比
                   us+sy 参考值为80%，如果us+sy 大于80%,说明可能存在CPU不足
                    id: 处于空闲的CPU百分比
                    wa:系统等待io的CPU时间百分比
                    st:来自与一个虚拟机偷取你的CPU时间的百分比
           查看额外
               查看所有CPU核信息：mpstat -P ALL 2
               每个进程使用CPU的用量分解信息  pidstat -u 1 - p 进程编号
       内存：free
            应用程序可用内存数   free -m
                   经验值：应用程序可用内存/系统物理内存>70%内存充足，应用程序可用内存/系统物理内存<20%内存不足，需要增加内存，20%<应用程序可用内存/系统物理内存<70%内存基本够用
            查看额外  pidstat -p 进程号 -r 采样间隔秒数
       硬盘：df  查看磁盘剩余空间数 df -h
       磁盘io：iostat
            磁盘i/o性能评估  iostat -xdk 2 3
                   rkB/s每秒读取数量kB
                   wkB/s每秒写入数据量kB
                   svctm i/o请求的平均服务时间，单位毫秒
                   await i/o请求的平均等待时间，单位毫秒，值越小，性能越好
                   utils 一秒中百分几的时间用于i/o操作，接近100%时，表示磁盘带宽跑满，需要优化程序或者增加磁盘
                   rkB/s,wkB/s根据系统应用不同会又不同的值，但有规律遵循，长期，超大数据读写，肯定不正常，需要优化程序读取
                   svctm的值与await的值很接近，表示几乎没有i/o等待，磁盘性能好
                   如果await的值远高于svctm的值，表示i/o队列队列等待太长，需要优化程序或更换更快磁盘
       网络io：ifstat
            默认本地没有，下载ifsta
            查看网络io
 假如生产环境出现CPU占用过高，请谈谈你的分析思路？
     结合linux和jdk命令一块分析
     案例步骤：1，先用top命令找出CPU占比最高的
               2，ps -ef或者jps进一步定位，得知是一个怎样的后台程序给我们惹事jsp -l
               3，定位到具体线程或者代码  
                    ps -mp 进程 -o THREAD,tid,time
                    参数解释：-m 显示所有的线程
                              -p pid进程使用CPU的时间
                              -o 该参数后是用户自定义格式
               4，将需要的线程id转换为16进制格式（英文小写格式）
                       print "%x\n" 有问题的线程的线程ID
               5，jstack 进程ID | grep tid（16进制线程id小写英文） -A60
对于jdk自带的jvm监控和性能分析工具用过哪些？一般你是怎么用的？       
       jps(虚拟机进程状况工具)
       jinfo(java 配置信息工具)
       jmap (内存影像工具)  生成java应用程序的堆快照和对象的统计信息
              映射堆快照   jmap -heap 进程id
              抓取堆内存  生成hprof文件并下载到本地
       jstat (统计信息监视工具)
       
github常用词含义：
      watch：会持续收到该项目的动态
      fork：复制某个项目到自己的Github仓库中
      star: 可以理解为点赞
      clone:将项目下载到本地
      follow:关注你感兴趣的作者，会收到他们的动态
   in关键词： 公式： xxx关键字  in:name  或者  description或readme
       seckill 秒杀  
              xxx in:name  项目名包含xxx的
              xxx in:descrition 项目描述包含xxx的
              xxx in:readme 项目的readme文件中包含xxx的
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
