1，面试题：谈谈对volatitle关键字的理解
volatitle：是java虚拟机提供的轻量级的同步机制
  1, 保证可见性
  2，不保证原子性
  3，禁止指令重排
  多线程情况下，普通的变量是没有可见性的，加了volatile关键字可以保证可见性
如何解决原子性：加sync  ,使用juc下的AtomicInterger(底层是CAS)

2,面试题：JMM（java内存模型）你谈谈？
  硬盘<内存<cpu
   主内存：电脑内存，比如8g,16g
   自己的工作内存：比如每个线程从主内存中拷贝到各自线程的工作内存
   可见性：一个线程修改了主物理内存，其它线程也能看到
 JMM本身是一种抽象的概念，并不真实存在，它描述的是一组规范或者规则，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式
   JMM关于同步的规定：
      1，线程解锁前，必须把共享变量的值刷新回主内存
      2，线程加锁前，必须读取主内存的最新值到自己的工作内存
      3，加锁解锁是同一把锁
   JMM要求：可见性，原子性，有序性   
    线程安全保证
   
      
  由于jvm运行程序的实体是线程，而每个线程创建时，JVM都会为其创建一个工作内存，（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而java
    内存模型中规定多有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将
     变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储
     着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成
     
     原子性指的是什么意思？不可分割，也即某个线程正在做某个具体业务时，中间不可以被加塞或者被分割，需要整体完整要么同时成功，要么同时失败
       number++在多线程下是非线程安全的
       
 计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分为三种
   源代码-》编译器优化的重排-》指令并行的重排-》内存系统的重排-》最终执行的指令
  单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致
  处理器在进行重排序时必须要考虑指令之间的数据依赖性
  多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测
  
  volatitle 实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象
   内存屏障（memory Barrier）：又称内存栅栏，是一个cpu指令，他的作用有两个：
      1，是保证特定操作的执行顺序
      2，是保证某些变量的内存可见性，（利用该特性实现，volatitle的内存可见性）
   由于编译器和处理器都能执行指令重排优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令
    重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排优化，内存屏障另外一个作用是强制刷新处各种CPU的缓存数据，因此任何CPU上的线程
    都能读取到这些数据的最新版本
    对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量值刷新回主内存中
    对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
 volatile应用：
   单机版单例模式：
        private static  SingletonDemo instance = null;
    private  SingletonDemo(){
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo");
    }
    public  static SingletonDemo  getSingletonDemo(){
        if (instance==null){
            instance=new SingletonDemo();
        }
        return instance;
    }
  多线程下单例模式：DCL+volatile
     private static volatile  SingletonDemo instance = null;
    private  SingletonDemo(){
        System.out.println(Thread.currentThread().getName()+"\t 我是构造方法SingletonDemo");
    }
    //DCL(double check lock双端检索机制)
    public  static SingletonDemo  getSingletonDemo(){
        if (instance==null){
            {
                synchronized(SingletonDemo.class){
                    if (instance==null){
                        instance=new SingletonDemo();
                    }
                }
            }
        }
        return instance;
    }

3. 面试题：CAS 是什么？ compareAndSwap 缩写  unsaf类（rd.jar包下的）+CAS思想（自旋）
       含义：比较并交换,比较当前工作内存中得值和主内存中得值，如果相同则执行规定操作，否则继续比较直到主内存和工作中得值一致为止
       应用：CAS有三个操作数，内存值V，旧得预期值A，要修改得更新值B
             当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做
       
     cas底层原理：如果知道谈谈unsafe类  
    1）Unsafe: 是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地方法（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作
       特定内存的数据，Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为java中CAS操作的执行依赖于Unsafe类的方法
    注意：Unsafe类中的所有方法都是native修改的，也就是说Unsafe类中的方法都是直接调用操作系统底层资源执行相应任务
    2）变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的
    3）变量value用volatitle修饰，保证了多线程之间的内存可见性
       CAS的全称为Compare-And-Swap，它是一条CPU并发原语
       它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的
       CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法，调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。它是一种完全依赖于硬件的
       功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成，用于完成某个功能的一个过程，并且原语
       的执行必须是连续的，在执行过程总不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题
       unsafe.getAndAddInt(Object var1,long var2,int var4)
       var1 AtomicInteger对象本身
       var2 该对象值得引用地址
       var4 需要变动得数量
       var5 是用过var1 var2找出得主内存中得真实的值
       用该对象当前的值和var5比较如果相同，更新var5+var4并且返回true，如果不容，继续取值然后再比较，直到更新完成
   CAS缺点：
        1，循环时间长，开销大（getAndAddInt方法执行时，有个do while，如果CAS失败，会一直进行尝试，如果CAS长时间一直不成功，可能会给CPU带来很大的开销）
        2，只能保证一个共享变量的原子操作（当对一个变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，
                                        但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性）
        3.引出来ABA问题
   
AtomicInteger--> CAS-->Unsafe-->CAS底层思想-->（CAS缺点引出）ABA-->原子引用更新-->如何规避ABA问题
 4 面试题：原子类AtomicInterger的ABA问题谈谈，原子更新引用知道吗？    
       CAS会导致“ABA问题”
       CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻比较并替换，那么在这个时间差会导致数据的变化，比如说一个线程one从内存位置V
            取出A，这时候另一个线程two，也是从内存中取出A，并且two进行了一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候one进行CAS
            操作发现内存中仍是A，然后线程one操作成功
      ABA问题： 尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的
     AtmicReference 原子引用，对象类型的原子引用 
  ABA问题的解决： AtomicStampedReference     
      代码：
       static AtomicReference<Integer> atomicReference = new AtomicReference<>(100);
    static  AtomicStampedReference atomicStampedReference= new AtomicStampedReference<>(100,1);

    public static void main(String[] args) {
        System.out.println("============以下是ABA问题的产生============");
        new Thread(()->{
            atomicReference.compareAndSet(100,101);
            atomicReference.compareAndSet(101,2019);

        },"t1").start();

        new Thread(()->{
            //暂停1秒，t2线程，保证t1线程完成一次ABA问题
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println( atomicReference.compareAndSet(100,2019)+"\t"+atomicReference.get());
        },"t2").start();
        //暂停一会线程
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("==============以下是ABA问题的解决==================");
        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            atomicStampedReference.compareAndSet(100,101,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t第二次版本号"+atomicStampedReference.getStamp());
            atomicStampedReference.compareAndSet(101,100,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+1);
            System.out.println(Thread.currentThread().getName()+"\t第3次版本号"+atomicStampedReference.getStamp());
        },"t3").start();

        new Thread(()->{
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName()+"\t第一次版本号"+stamp);
            //暂停3秒钟t4线程，保证上面的t3线程完成一次ABA操作
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            boolean result = atomicStampedReference.compareAndSet(100, 2020, stamp, stamp + 1);
            System.out.println(Thread.currentThread().getName()+"\t修改成功否"+result+"\t当前最新实际版本号"+atomicStampedReference.getStamp());
            System.out.println(Thread.currentThread().getName()+"\t当前最新实际版本号"+atomicStampedReference.getReference());
        },"t4").start();
    }
  5面试题：集合类的不安全问题 ,如果是多线程情况下，会报java并发修改异常 
    ArrayList   当new ArrayList的时候默认容量为10，Arraylist的add方法没有加锁，所以线程不安全，vector的add方法加有synchronized，所以线程安全
           底层是object类型的数组
           1，new Vector()
           2,Collections.synchronizedList(new ArrayList<>())
           3,new CopyOnWriteArrayList<>()
           写时复制：
              CopyOnWrite容器即写时复制的容器，往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行copy,复制出一个新的容器
                 Object[] newElements ，然后新的容器Object[] newElements里添加元素，添加元素后，再将原容器的引用指向新的容器setArray(newElements),这样
                 做的好处是可以对CopyOnWriter容器进行并发得读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读
                 和写不同的容器
        源码:  public boolean add(E e) {
                    final ReentrantLock lock = this.lock;
                    lock.lock();
                    try {
                        Object[] elements = getArray();
                        int len = elements.length;
                        Object[] newElements = Arrays.copyOf(elements, len + 1);
                        newElements[len] = e;
                        setArray(newElements);
                        return true;
                    } finally {
                        lock.unlock();
                    }
                } 
    HashSet;是线程不安全的，它和ArrayList类似，它的底层是HashMap，初始16，负载因子0.75扽HashMap
            它的add方法对应put方法，put(key,PRESENT)),添加的时候，只看key,value为一个恒定的常量
            对应的juc里的安全类为：new CopyOnWriteArraySet<>()
    
    HashMap:是线程不安全的
           对应JUC里的new ConcurrentHashMap<>()
  6面试题：公平锁/非公平锁/可重入锁/递归锁/自旋 谈谈你的理解？请手写一个自旋锁     
         公平锁：是指多个线程按照申请锁的顺序来获取 锁，类似排队打饭，先来后到
         非公平锁： 是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成
                优先级反转或者饥饿现象
        公平锁/非公平锁
            并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁
        关于两者的区别：
           公平锁： Threads acqure a fair  lock in the order in which they requested  it
           公平锁，就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是是等待队列的第一个，就占有锁
                 否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己
           非公平锁： a nonfair lock permists barging: threads requesting a lock  can jump ahead of  the  queue  of  waiting  threads if the 
                     lock happens to be  available  when  it is  requested
           非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就采用类似公平锁的那种方式
          java Reentrantlock而言
               通过构造函数指定该锁是否是否是公平锁，默认是非公平锁，非公平锁的优点在于吞吐量比公平锁大
          对于Synchronized而言，也是一种非公平锁
      可重入锁（也叫做递归锁）
        指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码；在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁
            也即是说：线程可以进入任何一个它已经拥有锁所同步着的代码块
        Synchronized/ReentrantLock 就是一个典型的可重入锁
        可重入锁最大的作用就是避免死锁（加锁要一对一对的加，如果new的锁多，关的少，就会卡死，如果new的少，关的多，则程序正常）
     自旋锁（spinlock)
       是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU（unsafe.getAndInt)
         //原子引用
              AtomicReference<Thread> atomicReference = new AtomicReference<>();

              public void mylock() {
                  Thread thread = Thread.currentThread();
                  System.out.println(Thread.currentThread().getName() + "\t come in ");
                  while (!atomicReference.compareAndSet(null, thread)) {

                  }
              }

              public void myUnloack() {
                  Thread thread = Thread.currentThread();
                  atomicReference.compareAndSet(thread, null);
                  System.out.println(Thread.currentThread().getName() + "\t invoked myunlock");
              }

              public static void main(String[] args) {
                  SingletonDemo singletonDemo = new SingletonDemo();
                  new Thread(() -> {
                      singletonDemo.mylock();
                      try {
                          TimeUnit.SECONDS.sleep(5);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      singletonDemo.myUnloack();
                  }, "AA").start();
                  try {
                      TimeUnit.SECONDS.sleep(1);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  new Thread(() -> {
                      singletonDemo.mylock();
                      try {
                          TimeUnit.SECONDS.sleep(5);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      singletonDemo.myUnloack();
                  }, "BB").start();
     独占锁（写锁）/共享锁（读锁）/互斥锁
       独占锁：指该锁一次只能被一个线程所持有，对ReentrantLock 和Synchronized而言都是独占锁
       共享锁：指该锁可被多个线程所持有
               对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁
       读锁的共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的
         多个线程同时读一个资源类没有任何问题，所以为了满足并发量，读取共享资源应该可以同时进行。但是如果有一个线程想去写共享资源类，就不应该
         再有其它线程可以对该资源进行读或写
          小总结：读-读能共存
                  读-写不能共存
                  写-写不能共存
                 写操作：原子+独占
       读写锁案例（手写缓存）
               private volatile Map<String, Object> map = new HashMap<>();
                private ReentrantReadWriteLock rwlock = new ReentrantReadWriteLock();
                public void put(String key, Object value) {
                    rwlock.writeLock().lock();
                    try {
                        System.out.println(Thread.currentThread().getName() + "\t正在写入" + key);
                        TimeUnit.MILLISECONDS.sleep(300);
                        map.put(key, value);
                        System.out.println(Thread.currentThread().getName() + "\t写入完成");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                        rwlock.writeLock().unlock();
                    }
                }
                public void get(String key) {
                    rwlock.readLock().lock();
                    try {
                        System.out.println(Thread.currentThread().getName() + "\t正在读");
                        Object result = map.get(key);
                        System.out.println(Thread.currentThread().getName() + "\t读取完成:" + result);
                        TimeUnit.MILLISECONDS.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                        rwlock.readLock().unlock();
                    }
                }
                public static void main(String[] args) {
                    SingletonDemo singletonDemo = new SingletonDemo();
                    for (int i = 0; i < 5; i++) {
                        final int tempInt = i;
                        new Thread(() -> {
                            singletonDemo.put(tempInt + "", tempInt + "");
                        }, String.valueOf(i)).start();

                    }
                    for (int i = 0; i < 5; i++) {
                        final int tempInt = i;
                        new Thread(() -> {
                            singletonDemo.get(tempInt + "");
                        }, String.valueOf(i)).start();

                    }
    CountDownLatch: 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒（班长锁门）
                    CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，调用线程会被阻塞，其它线程调用countDown方法会将计数器减一
                    （调用countDown方法的线程不会阻塞）当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行
    CyclicBarrier: CyclicBarrier的字面意思是可循环（Cyclic)使用的屏障（Barrier)，它要做的事情是让一组线程达到一个屏障（也可以叫同步点）时被阻塞
                  直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法（人到齐开会/收集七龙珠）
    Semaphore: 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制（争车位）
面试题：阻塞队列知道吗？
   队列+阻塞队列：
      当阻塞队列是空的时候，从队列种获取元素的操作将会被阻塞
      当阻塞队列是满的时候，往队列里添加元素的操作会被阻塞
    在多线程领域:所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足被挂起的线程又会自动被唤醒
     为什么需要BlickingQueue
       好处是我们不需要关系什么时候需要阻塞线程，什么时候需要唤醒线程，因为着一切BlockingQueue都给你包办了
       在concurrent包发布以前，多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度
      BlockingQueue是Collection下的接口
         #ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列，此队列FIFO（先进先出）原则对元素进行排序
         #linkedBlockingQueue:一个基于链表结构的阻塞队列（大小默认值为Integer.MAX_VALUE）阻塞队列，此队按照FIFO（先进先出）排序元素，吞吐量通常要高于ArrayBlockingQueue
         #SynchronousQueue:一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高，每一个put操作，总要等待一个take操作
         PriorityBlockingQueue：支持优先级排序的无界阻塞队列                                                                                                                               
         DelayQueue:使用优先级队列实现的延迟无界阻塞队列
         LinkedTransferQueue:由链表结构组成的无界阻塞队列
         LinkedBlockingDeque:由链表结构组成的双向阻塞队列
       BlockingQueue的核心方法：
        方法类型    抛出异常     特殊值     阻塞     超时
        插入        add(e)      offer(e)   put(e)   offer(e,time,unit)
        移除        remove()     poll()    take()   poll(time,unit)
        检查        element()    peek()    不可用   不可用
        抛出异常 ：当阻塞队列满时，再将队列里add插入元素会抛出IllegalStateException：Queue full
                   当阻塞队列空时，再往队列里remove,移除元素会抛出NoSuchElementException
        特殊值： 插入方法，成功为true,失败false
                 移除方法，成功返回处队列的元素，队列里面没有就返回null
        一直阻塞：当阻塞队列满时，生产者线程继续往队列里put元素，队列会一直阻塞生产线程直到put数据or相应中断退出
                 当阻塞队列空时，消费者线程试图从队列里take元素，队列会一直阻塞消费者线程直到队列可用
        超时退出：当阻塞队列满时，队列会阻塞生产者线程一定时间，超过后限时后生产者线程会退出       
   阻塞队列用在哪里？
      生产者消费之模式
             （多线程判断要用while判断）
      资源类：
              private volatile boolean  FLAG = true;
               private AtomicInteger atomicInteger = new AtomicInteger();
                BlockingQueue<String> blockingQueue=null;
               public Test(BlockingQueue<String> blockingQueue){
                   this.blockingQueue= blockingQueue;
                   System.out.println(blockingQueue.getClass().getName());
               }
               public void pro() throws Exception{
                   String data=null;
                   while (FLAG){
                       data = atomicInteger.getAndIncrement()+"";
                       boolean reValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
                       if (reValue){
                           System.out.println(Thread.currentThread().getName()+"\t插入队列"+data+"成功");
                       }else {
                           System.out.println(Thread.currentThread().getName()+"\t插入队列"+data+"失败");
                       }
                       TimeUnit.SECONDS.sleep(1);
                   }
                   System.out.println(Thread.currentThread().getName()+"\t 大老板叫停，表示Flag=false,生产动作结束");

               }
               public void consume() throws Exception{
                   String result=null;
                   while (FLAG){
                       result = blockingQueue.poll(2L, TimeUnit.SECONDS);
                       if (null==result||result.equalsIgnoreCase("")){
                          FLAG = false;
                           System.out.println(Thread.currentThread().getName()+"\t超过两秒没收到蛋糕，消费退出");
                           System.out.println();
                           System.out.println();
                           return;
                       }
                       System.out.println(Thread.currentThread().getName()+"\t消费队列"+result+"成功");
                   }


               }
               public void stop(){
                   this.FLAG = false;
               }
   测试类：
               public static void main(String[] args) {
                    Test test = new Test(new ArrayBlockingQueue<>(10));
                    new Thread(()->{
                        System.out.println(Thread.currentThread().getName()+"\t 生产者线程启动");
                        try {
                            test.pro();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    },"prod").start();
                    new Thread(()->{
                        System.out.println(Thread.currentThread().getName()+"\t 消费者线程启动");
                        try {
                            test.consume();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    },"consume").start();
                    try {
                        TimeUnit.SECONDS.sleep(5);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println();
                    System.out.println();
                    System.out.println();
                    System.out.println("5秒钟时间到，大老板main线程叫停活动结束;");
                    test.stop();
                }
             
      线程池
      消息中间件
       
    callable接口有返回值，runable接口没有返回值，futureTask是有有实现callable接口的构造入参，和实现runable接口
      多个线程抢一个futureTask，只会调用一次futureTask 
   线程池做的工作主要是可控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出了数量的线程
      排队等候，等其它线程执行完毕，再从队列中取出任务来执行
      它的主要特点：线程复用，控制最大并发数，管理线程
        第一：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗
        第二：提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行
        第三：提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控
   java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors,ExecutorService,ThreadPoolExecutor这几个类
      了解：
        Executors.newScheduledThreadPool()   时间调度
        Executors.newWorkStealingPool(lnt) java8新增   使用目前机器上可用的处理器作为它的并行级别
      重点：
        Executors.newFixedThreadPool(int)
           底层实现：
            public static ExecutorService newFixedThreadPool(int nThreads) {
            return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
            }
           主要特点：
              1，创建一个定长线程池，可控制线程最大并发数，超出的线程会再队列中等待
              2，newFixedThreadPool创建的线程池corePoolSize和maxmumPoolSize值是相等的，它使用的LinkedBlockingQueue
         Executors.newSingleThreadExecutor()
            底层实现：
                  public static ExecutorService newSingleThreadExecutor() {
                  return new FinalizableDelegatedExecutorService
                      (new ThreadPoolExecutor(1, 1,
                                              0L, TimeUnit.MILLISECONDS,
                                              new LinkedBlockingQueue<Runnable>()));
                  }
             主要特点：
               1，创建一个单线程化的线程池，它只会中唯一的工作线程来执行任务，保证所有任务按照指定顺序执行
               2，newSingleThreadExecutor将corePoolSize和maxmumPoolSize都设置为1，它使用的LinkedBlockingQueue        
        Executors.newwCachedThreadPool()
             底层实现：
                   public static ExecutorService newCachedThreadPool() {
                    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                                  60L, TimeUnit.SECONDS,
                                                  new SynchronousQueue<Runnable>());
                    }
             主要特点：
                1，创建要给可缓存线程池，如果线程池长度超过处理需要，可灵活回收线程，若无可回收，则新建线程
                2，newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Interger.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行
                    当线程空闲超过60秒，就销毁线程

     生产上这三种一个都不用，阿里巴巴java开发手册上的，
            不允许显式创建线程
           线程池不允许使用Excutors,而是通过ThreadPooleExecutor的方式，这样的处理方式，更加明确线程池的运行规则，规避资源耗尽的风险

     线程池的七大参数：
        1，corePoolSize:线程池中常驻核心线程数
             在创建了线程池后，当有请求任务来之后，就会安排池中的线程去执行请求任务，近似理解 为今日当值线程
             当线程池中的线程数达到corePoolSize后，就会把到达的任务放到缓存队列当中
        2，maximumPoolSiz:线程池能够容纳同时执行的最大线程数，此值必须大于等于1
        3，keepAliveTime：多余的空闲线程的存活时间，
             当前线程池数量超过corePoolSize时，当空闲线程达到KeepAliveTime值时，多余空闲线程会被销毁，直到只剩下corePoolSize个线程为止
               默认情况下，只有当线程池数大于corePoolSize时keepAliveTime才会起作用，直到线程池的线程数据不大于corePoolSize
        4，unit：keepAliveTime的单位
        5，workQueue：任务队列，被提交但尚未执行的任务
        6，threadFactory :表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可
        7，handle:拒绝策略，表示当队列满了，并且工作线程大于等于线程的最大线程数
             （等待队列满了，再也塞不下新任务，同时线程池的Max线程也达到了，无法继续为新任务服务，这时候我们需要拒绝策略机制合理处理这个问题）
            AbortPolicy （默认）：直接抛出RejectedExecutionException异常阻止系统正常运行
            DiscardPolicy ：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者
            CallerRunsPolucy ：抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再次提交当前任务
            DiscardOldesPolicy：直接丢弃任务，不予任何处理也不抛出异常，如果允许任务丢失，这是最好的一种方案
         以上策略均实现了RejectedExecutionHandler接口
      线程池的底层工作原理：
         1，在创建了线程池后，等待提交过来的任务请求
         2，当调用execute()方法添加一个请求任务时，线程池会做如下判断，
             2.1  如果正在运行的线程数小于corePoolSize，那么会马上创建线程运行这个任务
             2.2  如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列
             2.3  如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立即运行这个任务
             2.4  如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行
         3，当一个线程完成任务时，它会从队列中取下一个任务来执行
         4，当一个线程无事可做超过一定的时间（keepAliveTime）时线程池会判断：
                如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉
                所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小
       
       
       
       
       
       
       
       
       
       
       
       
       
