Singleton单例设计模式：  某个类在整个系统种只能有一个实例对象，可被获取和使用的代码模式    例如：代表JVM运行环境的Runtime类
1，私有化构造器
2，自行创建，并且用静态变量保存
3，向外提供整个实例
4，强调这个一个单例，我们可以用final修改
懒汉模式：直接创建对象，不存在线程安全问题
  1，直接实例化饿汉式（简洁直观）
  2，枚举式（最简洁）
  3，静态代码块饿汉式（适合复杂实例化）
懒汉式：延迟创建对象
  1，线程不安全（适合于单线程）
  2，线程安全（适用于多线程）
  3，静态内部类形式（适用于多线程）（最简洁）

3：类初始化和实例初始化
  1，类初始化过程
        1，一个类要创建实例需要先加载并初始化该类  main方法所在的类需要先加载和初始化
        2，一个子类要初始化需要先初始化父类
        3，一个类初始化就是要执行<clinit>()方法
          <clinit>()方法由静态类变量显示赋值代码和静态代码块组成
          类变量显示赋值代码和静态代码块代码从上到下顺序执行（静态代码块和静态实例变量同级，按顺序执行）
          <clinit>()方法只执行一次
  2，实例初始化过程
        1，实例初始化就是执行<init>()方法
            <init>()方法可能重载有多个，有几个构造器就有几个<init>方法
            <init>()方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码块组成
            非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行（非静态代码块和非静态实例变量同级，按顺序执行）
            每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法
            <init>方法的首行是super()或super（实参列表),即对应父类的<init>方法
            
  方法的重写override     
      1,哪些发给发不可以被重写
          final方法    静态方法   private等子类中不可见方法
      2，对象的多态性
          1，子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
          2，非静态方法默认的调用对象是this
          3，this对象在构造器或者<init>方法中就是正在创建的对象
  
