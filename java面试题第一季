Singleton单例设计模式：  某个类在整个系统种只能有一个实例对象，可被获取和使用的代码模式    例如：代表JVM运行环境的Runtime类
1，私有化构造器
2，自行创建，并且用静态变量保存
3，向外提供整个实例
4，强调这个一个单例，我们可以用final修改
懒汉模式：直接创建对象，不存在线程安全问题
  1，直接实例化饿汉式（简洁直观）
  2，枚举式（最简洁）
  3，静态代码块饿汉式（适合复杂实例化）
懒汉式：延迟创建对象
  1，线程不安全（适合于单线程）
  2，线程安全（适用于多线程）
  3，静态内部类形式（适用于多线程）（最简洁）

3：类初始化和实例初始化
  1，类初始化过程
        1，一个类要创建实例需要先加载并初始化该类  main方法所在的类需要先加载和初始化
        2，一个子类要初始化需要先初始化父类
        3，一个类初始化就是要执行<clinit>()方法
          <clinit>()方法由静态类变量显示赋值代码和静态代码块组成
          类变量显示赋值代码和静态代码块代码从上到下顺序执行（静态代码块和静态实例变量同级，按顺序执行）
          <clinit>()方法只执行一次
  2，实例初始化过程
        1，实例初始化就是执行<init>()方法
            <init>()方法可能重载有多个，有几个构造器就有几个<init>方法
            <init>()方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码块组成
            非静态实例变量显示赋值代码和非静态代码块代码从上到下顺序执行，而对应构造器的代码最后执行（非静态代码块和非静态实例变量同级，按顺序执行）
            每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法
            <init>方法的首行是super()或super（实参列表),即对应父类的<init>方法
            
  方法的重写override     
      1,哪些发给发不可以被重写
          final方法    静态方法   private等子类中不可见方法
      2，对象的多态性
          1，子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
          2，非静态方法默认的调用对象是this
          3，this对象在构造器或者<init>方法中就是正在创建的对象
 方法的参数传递机制：
     1，形参是基本数据类型
           传递的是数据值
     2，实参是引用数据类型
          传递地址值
          特殊的类型： String  ,包装类等对象不可变性
 面试题：假如有n阶阶梯，有几种走法
 递归做法：
          public Int f(Int n){
          if (n<1){
          throw new IllegalArgumentException(n+"不能小于1");
          }
          if(n==1 || n==2){
          return n;
          }
          return f(n-2)+f(n-1)
          }
  小结：方法调用自身称为递归，利用变量的原值推出新值称为迭代
         递归：
            优点：大问题转化为小问题，可以减少代码量，同事代码精简，可读性好
            缺点： 递归调用浪费了空间，而且递归太深容易造成堆栈的溢出
          迭代：
            优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销，
            缺点： 代码不如递归简介，可读性好
成员变量和局部变量（局部变量没有默认值，成员变量有默认值）
   区别：
       1，声明位置：
             局部变量：方法体{}中，形参，代码块{}中
             成员变量：类中方法外
                类变量： 有static修饰
                实例变量：没有static修饰
       2，修饰符：
             局部变量： final
             成员变量：public ,protected,private,final,static,volatile,transient
       3,值存储的位置
            局部变量：栈
            实例变量：堆
            类变量：方法区
       4，作用域
           局部变量：从声明处开始，到所属的}结束
           实例变量：在当前类中 "this." (有时this.可以缺省)，在其他类中"对象名."访问
           类变量：在当前类中 "类名." (有时类名. 可以省略），在其他类中“类名.” 或者"对象名."访问
       5，生命周期
           局部变量： 每一个线程，每一次调用执行都是新的生命周期
           实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的
           类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的
   当局部变量与xx变量重名时，如何区分：
         1，局部变量与实例变量重名
            在实例变量前面加’this."
         2,局部变量与类变量重名
            在类变量前面加"类名."
   
   就近原则
   变量的分类
     成员变量： 类变量，实例变量
     局部变量
   非静态代码块的执行： 每次创建实例对象都会执行
   方法的调用规则：调用一次执行一次
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
