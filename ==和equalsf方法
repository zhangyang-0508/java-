1、==操作符既可以用于比较基本的数据类型，也可以用于比较对象，而equals只可以用于对象之间的比较
2、在比较String类型的对象时，==操作符的原理只有两个变量是同一对象的引用时才会返回true，而equals方法只要两个变量的内容相同则返回true
3、其他类型的对象进行比较时，equals方法默认的原理是判断两者的内存地址是否相同，所以默认情况下与==操作符返回的结果相同，但是这里应该发现差别，也就是equals方法可以被重写—用户可以定制自己的equals方法，而==操作符不能被重写

普通对象，如果使用equals方法，默认比较的是地址值

当使用非自定义类的时候，hashcode相等，值不一定相等；值相等，hashcode一定相等。而当使用自定义类求hashcode的时候，即使初始化相同值，最后hashcode也不等。
假如只重写equals而不重写hashcode，那么Student类的hashcode方法就是Object默认的hashcode方法，由于默认的hashcode方法是根据对象的内存地址经哈希算法得来的，显然此时s1!=s2,故两者的hashcode不一定相等。

然而重写了equals，且s1.equals(s2)返回true，根据hashcode的规则，两个对象相等其哈希值一定相等，所以矛盾就产生了，因此重写equals一定要重写hashcode，而且从Student类重写后的hashcode方法中可以看出，重写后返回的新的哈希值与Student的两个属性有关。

以下是关于hashcode的一些规定：

两个对象相等，hashcode一定相等

两个对象不等，hashcode不一定不等

hashcode相等，两个对象不一定相等

hashcode不等，两个对象一定不等
在Java8种基本数据类型中equals()比较的都是内容，其实就是数值。

hashcode()方法和equals方法作用：
equals()作用：用于判断其他对象是否与该对象相同
HashCode()作用：给不同对象返回不同的hash code值，相当于识别码；
　　使用HashCode()时应当符合以下三点：

在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象无论调用多少次hashCode()，必须始终返回同一个integer；
如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()必须产生同一个integer结果；
调用equals(java.lang.Object)方法结果不相等的两个对象，调用二者各自hashCode()不一定不相同，可能相同，可能不同。　
 

重点
 　　在集合查找时，使用hashcode无疑能大大降低对象比较次数，提高查找效率！

　　Java对象的eqauls方法和hashCode方法是这样规定的：

　　　　1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。

　　　　2、如果两个对象的hashCode相同，它们并不一定相同。
    
    　一、相等（相同）的对象必须具有相等的哈希码（或者散列码），为什么？

　　假设A与B这两个对象相等，即他们equals的结果为true，但他们各自的哈希码不相同，但他们要存入同一个HashMap时，有可能就会因为哈希码不同导致计算得出的HashMap内部数组位置索引不一样，那么A、B很可能同时存入同一个HashMap中，但我们知道HashMap是不允许存放重复元素的。

 　　二、为什么两个对象的hashCode相同他们也不一定相同？

　　你的问题其实也是在说不同对象的hashCode有可能相同，产生这种结果的原因我个人觉得是由于“哈希算法”在生产哈希码时造成的，两个对象在某些方面具有高度一致性。正因为考虑到可能会出现这样的情况，所以HashMap在添加两个hashCode完全相同的对象时会在此哈希码指定的内部数组的位置索引处建立一个新的链表，然后将两个对象串起来放在该位置，这样就能在保证虽然hashCode相同仍能存入HashMap中，当然前提是他们调用equals()的返回值为false。

　　再补充一点，在业界中有一个专门的术语去描述这种现象，我们称之为哈希冲突，很显然，虽然哈希冲突是可以解决的，但没有人会希望经常看到它。

 

实际操作
　　在实际编写代码程序时，我们经常会被要求重写hashCode()和equals(),曾经我也对这个问题百思不得其解，但现在我也能向大家解释这其中的秘密了。

　　以HashSet为例，我们知道HashSet是继承Set接口，而Set接口由实现了Collection接口，HashSet中不允许出现重复值，而且元素的位置也是不确定的。

　　那么在这里介绍一下Java集合判断两个对象是否相等的规则是:

　　　　1.首先要判断两个对象的hashCode是否相等；

　　　　　　如果相等，进入第二步再判断；

　　　　       如果不相等，那么认为两个对象也不相等，结束判断。

　　　　2.判断两个对象用equals()是否相等。

　　　　　　如果这次判断也相等，则认为两个对象相等；

　　　　　　如果不相等，那么认为两个对象也不相等。
      
      为什么要进行两次判断呢？
　　可以不进行第一次的判断，但如果没有，实际使用效率会大大降低，尤其是在进行大量数据比较时。其实前面在介绍hashCode()时有过提及，即hashCode()相等时，equals()也可能不相等，所以我们就加上了第二条判断进行限制。总的来说，就是可以没有第一条判断，但必须要有第二条判断，但在实际开发中两条都最好写上，一旦出现大量数据需要判断时，仅靠equals()进行判断的话执行效率会大打折扣。

　　为什么Hashset添加了相等的元素呢，这是不是和Hashset的原则违背了呢？回答是：没有。因为在根据hashCode()对两次建立的new Student(1,“张三 ”)对象进行比较时，生成的是不同的哈希码值，所以Hashset把他当作不同的对象对待了，当然此时的equals()方法返回的值也不等。

        为什么会生成不同的哈希码值呢？原因就在于我们自己写的Student类并没有重新自己的hashCode()和equals()方法，所以在比较时，是继承的object类中的hashCode()，而object类中的hashCode()是一个本地方法，比较的是对象的地址（引用地址），使用new方法创建对象，两次生成的当然是不同的对象了，造成的结果就是两个对象的hashCode()返回的值不一样，所以Hashset会把它们当作不同的对象对待。

        怎么解决这个问题呢？答案是：在Student类中重写hashCode()和equals()方法。

　　可以看到重复元素的问题已经消除，根据重写的方法，即便两次调用了new Student(1,"张三")，我们在获得对象的哈希码时，根据重写的方法hashCode()，获得的哈希码肯定是一样的，当然根据equals()方法我们也可判断是相同的，所以在向hashset集合中添加时把它们当作重复元素看待了。

　　刚才使用的重写是用快捷键进行的，我们也可以手敲，不过写这么多就没必要了。

做个总结
　　重点是equals，重写hashCode只是技术要求（为了提高效率）；
　　为什么要重写equals呢？因为在Java的集合框架中，是通过equals来判断两个对象是否相等的；
　　在hibernate中，经常使用set集合来保存相关对象，而set集合是不允许重复的。在向HashSet集合中添加元素时，其实只要重写equals()这一条也可以。但当hashset中元素比较多时，或者是重写的equals()方法比较复杂时，我们只用equals()方法进行比较判断，效率也会非常低，所以引入了hashCode()这个方法，只是为了提高效率，且这是非常有必要的。
public int hashCode(){ 
   return 1; //等价于hashcode无效 
}
　　这样做的效果就是在比较哈希码的时候不能进行判断，因为每个对象返回的哈希码都是1，每次都必须要经过比较equals()方法后才能进行判断是否重复，这当然会引起效率的大大降低。
